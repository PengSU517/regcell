---
title: "simu"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{simu}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup, message=FALSE, warning=FALSE}
library(regcell)
library(tidyverse)
```


# Simulation 
The following code is utilized for running simulations (in parallel).

```{r echo=TRUE, eval=FALSE}
library(doParallel) ####parallel computation
registerDoParallel(cores=10)
getDoParWorkers()

###### data generation settings

{
  ms = 1:200   # the number of simulations
  ns = c(200) # sample size
  ps = c(50) # num of candidate predictors
  prs = c(10) # number of informative candidata predictors
  es = c(0, 0.02, 0.05) # contamination rates
  rs = c(0.5) # correlation among predictors
  gammas = c(0, 2, 4, 6, 8) # magnitude of outlyingness
  # sigmas = c(2) # variance of residuals, not used
  dfs = c(4, Inf) # degrees of freedom generating predictors
  outtypes = c("cellwise") # types of contamination
}



##### methods compared
mtds = list(
  ## spase shooting S, codes arefrom https://github.com/ineswilms/sparse-shooting-S 
  ## package is available from https://github.com/PengSU517/shootings
  # sss = function(y, x){shootings::sparseshooting(x,y)$coef},
  
  ## Rlars, from package robustHD
  rlars = function(y, x){regcell::Rlars(y, x)$betahat}, 
  
  ## MM-Lasso, from https://github.com/esmucler/mmlasso
  # mmlasso = function(y,x){mmlasso::mmlasso(x,y)$coef.MMLasso.ad}, 
  
  ## sparse LTS, from package robustHD, an alternative using BIC is regcell::SLTS
  slts = function(y,x){robustHD::sparseLTS(x,y)$coefficients},
  
  ## cellwise regularized Lasso without post regression
  cell_lasso = function(y,x){ 
    fit = regcell::sregcell_std(y = y, x = x)
    return(c(fit$intercept_hat, fit$betahat))
  },

  ## cellwise regularized Lasso with post regression
  cell_lasso_post = function(y,x){
    fit = regcell::sregcell_std(y = y, x = x)
    return(c(fit$intercept_hat_post, fit$betahat_post))
  },

  ## Lasso, from package glmnet
  lasso  = function(y,x){ 
    return(regcell::lassocv(y,x)$betahat)
  }

)

{
  result <- foreach(m = ms,
                    .packages = c("robustHD", "robustbase" , "mmlasso","shootings", "cellWise", "regcell"))%:%
    foreach(n = ns)%:%
    foreach(p = ps)%:%
    foreach(pr = prs)%:%
    foreach(e = es)%:%
    foreach(r = rs)%:%
    foreach(gamma = gammas)%:%
    # foreach(sigma = sigmas)%:%
    foreach(df = dfs)%:%
    foreach(outtype = outtypes)%dopar% {

      {
        seed = m
        set.seed(seed = seed) ##set random seed
        beta = c(rep(1,pr),rep(0,p-pr))#*c(1,-1)  ###set beta
        dataset = regcell::genevar(n = n, p = p, e = e, r = r, beta = beta,intercept = 1,
                                   gamma = gamma, df = df, outtype = outtype, sigma = 3,
                                   mux = rep(0,p), scalex = 1) ##generate datasets
        x  = dataset$x # the clean design matrix
        xc = dataset$xc # the contaminated design matrix
        y  = dataset$y # the response
        ynew = dataset$ynew # # another response vector for calculating prediction errors
      }

      rst = list()
      if(((e!=0)&(gamma!=0))|((e==0)&(gamma==0))){
        for (mtd in 1:length(mtds)) {
          rst[[mtd]]=rep(NA, 27)
          try({
            timing  = system.time({betahat = mtds[[mtd]](y,x)})["elapsed"] ##calculate time consuming
            mspe = mean((ynew - cbind(1,xc)%*%betahat)^2) #mean squared prediction error
            mape = mean(abs(ynew - cbind(1,xc)%*%betahat)) # mean absolute prediction error
            rtmspe = sqrt(mean(sort((ynew - cbind(1,xc)%*%betahat)^2)[1:(0.9*n)]))## root of trimed mspe 

            tpf<-function(betahat, beta){sum((as.logical(betahat)==as.logical(beta))[1:pr])} 
            tnf<-function(betahat,beta){sum((as.logical(betahat)==as.logical(beta))[-(1:pr)])} 
            tp = tpf(betahat[-1], beta) # true positive rate
            tn = tnf(betahat[-1], beta) # true negative rate

            rst[[mtd]] = c(m = m, n = n, p = p, pr = pr, e = e, r = r,
                           gamma = gamma, outtype = outtype, df = df,
                           method = names(mtds)[mtd], seed =seed,
                           MSPE= mspe, MAPE = mape, RTMSPE = rtmspe,
                           TP = tp, FP = (p-pr)-tn, Time = timing, betahat[2:11])
          }, TRUE
          )

        }
      }else{
        rst[[1]] = rep(NA,27)
      }
      rst
    }

  save(result, file = "result_simu.RData")
}


```


# Analysis

The following code is employed to analyze the generated results.

```{r echo=TRUE, eval=FALSE}
result1 = as.data.frame(t(as.data.frame(result)))
names(result1) = c("m", "n", "p", "pr", "e", "r", "gamma", "outtype", "df", "method", "seed",
                        "MSPE", "MAPE", "RTMSPE", "TP", "FP", "Time", paste("betahat", 1:10))

result2 = result1 %>% mutate(across(c(1:7,9, 11:21), as.numeric), 
                             across(5:11, as.factor), 
                             TN = p-pr-FP,
                             FN = pr - TP,
                             BACC = (TP/pr + TN/(p-pr))/2,
                             F1 = 2*TP/(2*TP + FP + FN),
                             RMSPE = sqrt(MSPE))

levels(result2$e) = c("e = 0%", "e = 2%", "e = 5%")
levels(result2$df) = c("t(4)", "Normal")
result2$df = factor(result2$df, levels = c("Normal" ,"t(4)" ))

levels(result2$gamma) = c(" ", "2", "4", "6", "8")

levels(result2$method) = c("CR-Lasso", "Lasso", "MM-Lasso", "RLars", "SLTS", "SSS")
result2$method = factor(result2$method, levels = c("CR-Lasso", "SSS", "RLars", "MM-Lasso", "SLTS", "Lasso"))
result2 = result2[complete.cases(result2),]
result3 = result2 %>% filter((p==50))
```


```{r fig.width=10, fig.height=7, echo=TRUE, eval=FALSE}
colorset = c("CR-Lasso" ="#F8766D",
             "SSS" = "#C49A00",
             "RLars" = "#53B400",
             "MM-Lasso" = "#00C094",
              "SLTS" = "#00B6EB",
            "Lasso" = "#A58AFF")

p1 = ggplot(data = result3)+
  geom_boxplot(aes(fill = method, x = gamma, y = RMSPE),outlier.size = 0.2, lwd = 0.4)+
  facet_grid(df~e, scales = "free", space = "free_x") +
  scale_fill_manual(values = colorset)+
  theme_bw()+
  labs(x = expression(gamma*": magnitude of outlyingness"))+
  
  theme(text= element_text(size=20), 
        #axis.text.x = element_blank(),
        legend.position = "bottom")
p1


```



```{r echo=TRUE, eval=FALSE}

summary = result3 %>% group_by(n,p, pr,e,r,gamma, df, method,outtype) %>% summarise(
  TP = mean(TP, na.rm = T),
  FP = mean(FP, na.rm = T),
  TPR = mean(TP/pr, na.rm = T),
  FPR = mean(FP/(p-pr), na.rm = T),
  TNR = 1-FPR,
  BACC = mean(BACC),
  F1 = mean(F1))

```


```{r fig.width=10, fig.height=7, echo=TRUE, eval=FALSE}

p2 = ggplot(data = summary, aes(x = gamma, y = F1, group = method))+
  geom_point(aes(color = method))+
  geom_line(aes(linetype = method, color = method))+ 
  facet_grid(df~e, scales = "free", space = "free_x") +
  ylim(0,1)+
  theme_bw()+
  labs(x = expression(gamma*": magnitude of outlyingness"), 
       y = expression(F[1]))+
  theme(text= element_text(size=20), 
        legend.position = "bottom")
p2


```








